#  POC Django + Domain Driven Design (DDD)

## Introduction et explication du fonctionnement du DDD


## Introduction au Domain Driven Design (DDD)
Le Domain Driven Design est une approche de dÃ©veloppement logiciel qui place le domaine mÃ©tier au cÅ“ur de la conception. L'objectif est de crÃ©er un logiciel qui reflÃ¨te prÃ©cisÃ©ment les concepts mÃ©tier et les processus de l'organisation.

## Les trois couches principales en DDD :
### Domain Layer - Le cÅ“ur mÃ©tier :
 Contient les entitÃ©s, value objects, rÃ¨gles mÃ©tier et services de domaine

### Application Layer - Orchestration :
 Coordonne les use cases et fait le lien entre le domaine et l'infrastructure

### Infrastructure Layer - DÃ©tails techniques :
Persistence, APIs, frameworks (Django dans notre cas)

## Structure du projet:
```
poc-django-ddd/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ users/                       # DOMAIN LAYER - CÅ“ur mÃ©tier
â”‚   â”‚   â”œâ”€â”€ core/                   # ModÃ¨les mÃ©tier purs
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py           # EntitÃ©s et Value Objects
â”‚   â”‚   â”‚   â”œâ”€â”€ exceptions.py       # Exceptions mÃ©tier
â”‚   â”‚   â”‚   â””â”€â”€ commands.py         # Commandes (CQRS)
â”‚   â”‚   â”œâ”€â”€ services/               # SERVICES - Logique mÃ©tier
â”‚   â”‚   â”‚   â””â”€â”€ user_services.py    # Services de domaine
â”‚   â”‚   â””â”€â”€ adapters/               # ADAPTERS - Interfaces techniques
â”‚   â”‚       â””â”€â”€ repository.py       # Interface de repository
â”‚   â””â”€â”€ interface_django/           # INFRASTRUCTURE LAYER - Django
â”‚       â”œâ”€â”€ account/                # App Django
â”‚       â”‚   â”œâ”€â”€ models.py           # ModÃ¨les Django (persistence)
â”‚       â”‚   â”œâ”€â”€ views.py            # ContrÃ´leurs API
â”‚       â”‚   â””â”€â”€ urls.py             # Routes API
â”‚       â””â”€â”€ interface_django/
â”‚           â””â”€â”€ settings.py         # Configuration Django
â”œâ”€â”€ tests/                          # Tests de toutes les couches
â”‚   â”œâ”€â”€ unit/                       # Tests unitaires
â”‚   â””â”€â”€ integration/                # Tests d'intÃ©gration
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

## Explication DÃ©taillÃ©e de Chaque Couche
### 1. Domain Layer - Le CÅ“ur MÃ©tier

Le Domain Layer est le cÅ“ur mÃ©tier dâ€™une application, câ€™est lÃ  oÃ¹ rÃ©side toute la logique mÃ©tier et les rÃ¨gles de lâ€™organisation.
Il doit Ãªtre indÃ©pendant de toute technologie, câ€™est-Ã -dire sans dÃ©pendances Ã  Django, Flask, SQLAlchemy, PostgreSQL, Redis, ou toute autre librairie externe.

CaractÃ©ristiques principales :

Isolation totale :

Aucune dÃ©pendance Ã  lâ€™infrastructure (DB, frameworks web, API externes).

Ã‰crit en Python pur dans notre cas.

RÃ¨gles mÃ©tier :

Les invariants (exemple : un email valide, un mot de passe doit respecter certaines rÃ¨gles).

Les rÃ¨gles de sÃ©curitÃ© (exemple : un utilisateur inactif ne peut pas se connecter).

Les comportements mÃ©tier (exemple : activer/dÃ©sactiver un compte, valider un OTP, gÃ©rer des droits dâ€™accÃ¨s).

Ã‰lÃ©ments du Domain Layer :

EntitÃ©s (Entities) : objets qui possÃ¨dent une identitÃ© unique (exemple : User, Order, Invoice).

Valeurs (Value Objects) : objets sans identitÃ© propre, mais dÃ©finis uniquement par leurs attributs (exemple : Email, Money, Address).

Services de domaine : logique mÃ©tier complexe qui ne se rattache pas directement Ã  une entitÃ© (exemple : gÃ©nÃ©ration dâ€™un token dâ€™authentification, validation de rÃ´les).

Ã‰vÃ©nements de domaine (Domain Events) : Ã©vÃ©nements significatifs du mÃ©tier (exemple : UserRegistered, PasswordChanged).

IndÃ©pendance :

Tu pourrais exÃ©cuter le Domain Layer tout seul, sans base de donnÃ©es ni serveur web.

Si demain tu passes de Django Ã  FastAPI, ou de PostgreSQL Ã  MongoDB â†’ le domaine reste inchangÃ©.

NB: dans le domaine layer on oublie tous framework base de donnÃ©e ontravail en python pur c'est ici que toute les bonne pratique de programmation intervienne c'est ici que les tests unitaire ont lieu

users/core/models.py - EntitÃ©s et Value Objects

```
import uuid
from datetime import datetime
import re

class User:
    """
    ENTITÃ‰ MÃ‰TIER - ReprÃ©sente un utilisateur dans le domaine
    Pure Python, aucune dÃ©pendance Ã  Django
    """
    
    # Expression rÃ©guliÃ¨re pour validation email
    EMAIL_REGEX = r"^[\w\.-]+@[\w\.-]+\.\w+$"

    def __init__(self, email: str, password="Password123@#", is_active: bool = True, created_at: datetime = None):
        # IdentitÃ© unique de l'entitÃ©
        self.id = str(uuid.uuid4())
        self.password = password
        self.email = self._validate_email(email)  # Validation mÃ©tier
        self.is_active = is_active
        self.created_at = created_at or datetime.utcnow()
        self.seen = set()  # Exemple de collection mÃ©tier

    # MÃ©thodes mÃ©tier - comportements de l'entitÃ©
    def _validate_email(self, email: str) -> str:
        """RÃˆGLE MÃ‰TIER: Validation du format email"""
        if not re.match(self.EMAIL_REGEX, email):
            raise ValueError("Email invalide")
        return email.lower().strip()

    def activate(self):
        """COMPORTEMENT MÃ‰TIER: Activer un utilisateur"""
        self.is_active = True

    def deactivate(self):
        """COMPORTEMENT MÃ‰TIER: DÃ©sactiver un utilisateur"""
        self.is_active = False

    # MÃ©thodes techniques
    def __repr__(self):
        return f"User(id={self.id}, email={self.email}, is_active={self.is_active}, created_at={self.created_at})"

    def __eq__(self, value):
        """IDENTITÃ‰: Deux users sont Ã©gaux s'ils ont le mÃªme ID"""
        if isinstance(value, User):
            return self.id == value.id
        return False

    def __hash__(self):
        """HASH: BasÃ© sur l'ID unique"""
        return hash(self.id)
```
users/core/exceptions.py - Exceptions MÃ©tier

```
class UserAlreadyExists(Exception):
    pass


class UserNotFound(Exception):
    pass


```

### tests unitaire dans le domaine layer
#### test de crÃ©ation d'un nouveau utilsateur
 ```
 # nous testons ici le bon cas c'est a dire lorsque les informations sont bien forunie
 
 from users.core.models import User


def test_user_model():
    user = User(email="l9v3h@example.com", is_active=True)
    print(user)
    assert user.email == "l9v3h@example.com"
    assert user.is_active

 ```

### repository patterns

DÃ©finition du Repository Pattern

En DDD, le Repository est un service technique qui fait lâ€™intermÃ©diaire entre le domaine et la persistence (ex: base de donnÃ©es, fichiers, cache, API externe).

 En clair :

Le domaine ne connaÃ®t pas la base de donnÃ©es.

Le domaine demande juste au repository : "Donne-moi cet utilisateur", "Sauvegarde cet utilisateur".

Le repository se charge dâ€™aller dans la DB (ou autre systÃ¨me) et de retourner un objet du domaine (User), pas un objet technique (UserModel Django).

 RÃ´le du Repository

Abstraction de la persistence :
Le domaine ne doit pas dÃ©pendre du choix de la DB ou de lâ€™ORM.
(Aujourdâ€™hui tu utilises Django ORM, demain tu peux passer Ã  SQLAlchemy ou MongoDB sans changer le domaine.)

Interface mÃ©tier simple :
Le repository expose des mÃ©thodes simples comme add, get_by_id, get_by_email, list, exists.

Retourner des objets du domaine uniquement :
Jamais dâ€™objets Django ORM ou SQLAlchemy dans le domaine, toujours des entitÃ©s User.

 Pourquoi deux versions ?

InMemoryRepository : utilisÃ© pour les tests unitaires du domaine â†’ rapide, pas besoin de base de donnÃ©es.

DjangoUserRepository : utilisÃ© dans lâ€™infrastructure â†’ implÃ©mentation rÃ©elle qui utilise lâ€™ORM Django.

Les deux implÃ©mentent la mÃªme interface AbstractUserRepository, donc le domaine peut travailler avec lâ€™un ou lâ€™autre sans rien changer.
NB: le repository pattern ne doit avoir en Ã©alitÃ© quye deux fonction ) loa rigueur 3 car le repo ne fait ajouter(add) ou retoruner (get) des donnÃ©es dans la base de donnÃ©es

 Exemple simplifiÃ© : deux fonctions essentielles

Tu disais quâ€™un repository doit au moins avoir deux fonctions : add et get.
Exactement !
On peut rÃ©duire Ã§a au minimum vital :


```
from abc import ABC, abstractmethod
from typing import Optional, List
from users.core.models import User
from typing import Optional, List


class AbstractUserRepository(ABC):
    """Interface du UserRepository dans le domaine"""

    def exists(self, email: str) -> bool:
        return self._exists(email)

    def get_by_email(self, email: str) -> Optional[User]:
        return self._get_by_email(email)

    def update(self, user: User) -> User:
        return self._save(user)

    def get_by_id(self, user_id: str) -> Optional[User]:
        return self._get_by_id(user_id)

    def list(self) -> List[User]:
        return self._list()

    def save(self, user: User) -> User:
        return self._save(user)

    @abstractmethod
    def _get_by_email(self, email: str) -> Optional[User]:
        pass

    @abstractmethod
    def _get_by_id(self, user_id: str) -> Optional[User]:
        pass

    @abstractmethod
    def _list(self) -> List[User]:
        pass

    @abstractmethod
    def _save(self, user: User) -> User:
        pass

```

Puis deux implÃ©mentations :

ðŸ”¹ En mÃ©moire (tests unitaires)

```

class InMemoryRepository(AbstractUserRepository):
    def __init__(self):
        self._users = []

    def _exists(self, email: str) -> bool:
        return any(user.email == email for user in self._users)

    def _get_by_email(self, email: str) -> Optional[User]:
        return next((user for user in self._users if user.email == email), None)

    def _get_by_id(self, user_id: str) -> Optional[User]:
        return next((user for user in self._users if user.id == user_id), None)

    def _list(self) -> List[User]:
        return self._users

    def _save(self, user: User) -> User:
        self._users.append(user)
        return user

```
Avec Django ORM (prod)
```
from users.core.models import User
from interface_django.account.models import UserModel
from users.adapters.repository import AbstractUserRepository
from typing import Optional, List


class DjangoUserRepository(AbstractUserRepository):
    def exists(self, email: str) -> bool:
        return UserModel.objects.filter(email=email).exists()

    def _get_by_email(self, email: str) -> Optional[User]:
        obj = UserModel.objects.filter(email=email).first()
        return obj.to_domain() if obj else None

    def _get_by_id(self, user_id: str) -> Optional[User]:
        obj = UserModel.objects.filter(id=user_id).first()
        return obj.to_domain() if obj else None

    def _list(self) -> List[User]:
        return [u.to_domain() for u in UserModel.objects.all()]

    def _save(self, user: User) -> User:
        obj = UserModel.from_domain(user)
        obj.save()
        return obj.to_domain()

    def _exists(self, email: str) -> bool:
        return self.exists(email)

```

Test unitaire repository patterns

```
import pytest
from users.core.models import User
from users.adapters.repository import InMemoryRepository


@pytest.fixture
def repo():
    return InMemoryRepository()


def test_save_and_get_by_id(repo):
    user = User(email="test@example.com")
    saved_user = repo.save(user)

    assert saved_user.email == "test@example.com"
    assert repo.get_by_id(saved_user.id) == saved_user


def test_exists_and_get_by_email(repo):
    user = User(email="exists@example.com")
    repo.save(user)

    assert repo.exists("exists@example.com") is True
    assert repo.exists("notfound@example.com") is False
    assert repo.get_by_email("exists@example.com") == user


def test_list_users(repo):
    u1 = User(email="a@example.com")
    u2 = User(email="b@example.com")
    repo.save(u1)
    repo.save(u2)

    users = repo.list()
    assert len(users) == 2
    assert u1 in users and u2 in users


```
Tests d'integration django

```

import pytest
from users.adapters.django_repository import DjangoUserRepository
from users.core.models import User
from interface_django.account.models import UserModel

pytestmark = pytest.mark.django_db


def test_save_and_get_user():
    repo = DjangoUserRepository()
    user = User(email="django@example.com", password="123456")

    saved_user = repo.save(user)

    assert saved_user.email == "django@example.com"
    assert repo.exists("django@example.com")


def test_get_by_email_returns_user():
    repo = DjangoUserRepository()
    user = User(email="test2@example.com", password="pwd")
    repo.save(user)

    fetched = repo.get_by_email("test2@example.com")

    assert fetched is not None
    assert fetched.email == "test2@example.com"


def test_list_users():
    repo = DjangoUserRepository()
    repo.save(User(email="u1@example.com", password="p1"))
    repo.save(User(email="u2@example.com", password="p2"))

    users = repo.list()
    assert len(users) == 2

```
RÃ©sultat :

Dans les tests unitaires : on passes InMemoryUserRepository() â†’ rapide, sans DB.

Dans Django (prod) : on passes DjangoUserRepository() â†’ Ã§a persiste en DB.

Le domaine nâ€™a aucune idÃ©e de ce quâ€™il y a derriÃ¨re.


## Service layer


Parfait ! Voici comment tu peux documenter **le Service Layer** dans ton README ou dans un tutoriel pour ton POC, en gardant le style DDD et en utilisant ton exemple `UserService`.

---

# ðŸ›  Service Layer â€“ Orchestration des Use Cases

## 1. DÃ©finition

Le **Service Layer** (ou **Application Layer**) est la couche qui :

1. **Orchestre les cas dâ€™usage (use cases)** : il manipule les entitÃ©s du domaine pour exÃ©cuter un scÃ©nario mÃ©tier complet.
2. **Coordonne le domaine et les repositories** : il ne connaÃ®t pas la DB directement, il interagit via des interfaces abstraites.
3. **Applique les rÃ¨gles mÃ©tier** dÃ©jÃ  dÃ©finies dans les entitÃ©s, mais sans les dupliquer.

> Le Service Layer ne contient pas de logique mÃ©tier complexe lui-mÃªme, il orchestre les entitÃ©s et leur comportement.

---

## 2. Fonctionnement

1. **Prendre une commande (Command)** : un objet qui encapsule les donnÃ©es nÃ©cessaires au use case (ex: `RegisterUserCommand`).
2. **VÃ©rifier les rÃ¨gles mÃ©tier** via les entitÃ©s ou les exceptions (ex: vÃ©rifier si lâ€™utilisateur existe dÃ©jÃ ).
3. **Orchestrer le workflow** : crÃ©er ou modifier des entitÃ©s.
4. **Appeler le Repository** pour persister ou rÃ©cupÃ©rer des donnÃ©es.
5. **Retourner le rÃ©sultat** sous forme dâ€™entitÃ© ou de DTO.

---

## 3. Bonnes pratiques

* Chaque use case correspond Ã  une **mÃ©thode du service** (ex: `register`, `authenticate`).
* Injecter les **repositories via le constructeur** pour pouvoir remplacer facilement la DB par un repository en mÃ©moire (tests unitaires).
* Les mÃ©thodes doivent rester **cohÃ©rentes et simples** : pas de logique mÃ©tier complexe dedans.
* Toujours travailler avec les **entitÃ©s du domaine** et jamais avec des objets techniques comme un modÃ¨le Django.

---

## 4. Exemple concret â€“ `UserService`

```python
import hashlib
from users.core.models import User
from users.core.exceptions import UserAlreadyExists, UserNotFound
from users.core.commands import RegisterUserCommand
from users.adapters.repository import AbstractUserRepository


class UserService:
    def __init__(self, repo: AbstractUserRepository):
        self.repo = repo

    def register(self, cmd: RegisterUserCommand) -> User:
        """CrÃ©er un nouvel utilisateur"""
        if self.repo.exists(cmd.email):
            raise UserAlreadyExists(
                f"Un utilisateur avec l'email {cmd.email} existe dÃ©jÃ ."
            )

        # Hash simple du mot de passe ( pour POC uniquement, pas en prod !)
        password_hash = self._hash_password(cmd.password)

        user = User(email=cmd.email)
        user.password_hash = password_hash  # on enrichit l'entity avec le hash
        return self.repo.save(user)

    def authenticate(self, email: str, password: str) -> User:
        """VÃ©rifier login/password"""
        user = self.repo.get_by_email(email)
        if not user:
            raise UserNotFound("Utilisateur introuvable")

        if user.password_hash != self._hash_password(password):
            raise ValueError("Mot de passe incorrect")

        return user

    # ---------- Utils ----------
    def _hash_password(self, password: str) -> str:
        return hashlib.sha256(password.encode()).hexdigest()

```

---

## 5. Exemple dâ€™utilisation dans lâ€™application

```python
# CrÃ©ation d'un repository (mÃ©moire ou DB)
repo = InMemoryUserRepository()  # pour les tests
service = UserService(repo)

# 1. Enregistrer un nouvel utilisateur
cmd = RegisterUserCommand(email="alice@example.com", password="Secret123!")
user = service.register(cmd)
print(user)

# 2. Authentification
auth_user = service.authenticate("alice@example.com", "Secret123!")
print(auth_user)
```

Tests Unitaire inmemrory
```
import pytest
from users.core.commands import RegisterUserCommand
from users.services.user_services import UserService
from users.core.exceptions import UserAlreadyExists, UserNotFound
from users.adapters.repository import InMemoryRepository


@pytest.fixture
def service():
    return UserService(InMemoryRepository())


def test_register_user(service):
    cmd = RegisterUserCommand(email="test@example.com", password="secret")
    user = service.register(cmd)

    assert user.email == "test@example.com"
    assert hasattr(user, "password_hash")


def test_register_duplicate_user(service):
    cmd = RegisterUserCommand(email="dup@example.com", password="secret")
    service.register(cmd)
    with pytest.raises(UserAlreadyExists):
        service.register(cmd)


def test_authenticate_success(service):
    cmd = RegisterUserCommand(email="login@example.com", password="mypassword")
    user = service.register(cmd)

    authenticated = service.authenticate("login@example.com", "mypassword")
    assert authenticated == user


def test_authenticate_fail(service):
    cmd = RegisterUserCommand(email="fail@example.com", password="rightpass")
    service.register(cmd)

    with pytest.raises(ValueError):  # mauvais password
        service.authenticate("fail@example.com", "wrongpass")

    with pytest.raises(UserNotFound):  # mauvais email
        service.authenticate("notfound@example.com", "whatever")

```
Tests d'inegration django

```
import pytest
from users.services.user_services import UserService
from users.adapters.django_repository import DjangoUserRepository
from users.core.commands import RegisterUserCommand
from users.core.exceptions import UserAlreadyExists, UserNotFound

pytestmark = pytest.mark.django_db


@pytest.fixture
def service():
    return UserService(DjangoUserRepository())


def test_register_user(service):
    cmd = RegisterUserCommand(email="new@example.com", password="mypassword")
    user = service.register(cmd)
    assert user.email == "new@example.com"


def test_register_duplicate_user(service):
    cmd = RegisterUserCommand(email="dup@example.com", password="secret")
    service.register(cmd)
    with pytest.raises(UserAlreadyExists):
        service.register(cmd)

```

 Avec cette architecture :
>
> * Le **Service Layer** orchestre la logique mÃ©tier sans connaÃ®tre la DB.
> * Le **Domain Layer** reste indÃ©pendant et testable.
> * Le code est **testable, maintenable et Ã©volutif**.

---

## Service Layer + Unit of Work (UoW) dans DDD
Quâ€™est-ce que le Unit of Work ?

Le Unit of Work est un pattern qui garantit que toutes les opÃ©rations sur la base de donnÃ©es sont exÃ©cutÃ©es dans un seul contexte transactionnel.

Il regroupe toutes les modifications (crÃ©ation, mise Ã  jour, suppression) dans une transaction.

Si une erreur survient, il permet de rollback toutes les modifications.

Il est particuliÃ¨rement utile pour les use cases complexes qui touchent plusieurs entitÃ©s Ã  la fois.

Dans notre architecture DDD avec Django, le Unit of Work sert de couche entre le Service Layer et les Repositories.

si le repository patterns perme de faire la persistence 
UOW permet d'assurer le principe ACID sur la base de donnÃ©e
exemple:
```
from abc import ABC, abstractmethod
from users.adapters.repository import AbstractUserRepository, InMemoryRepository
from users.adapters.django_repository import DjangoUserRepository


class AbstractUnitOfWork(ABC):
    users: AbstractUserRepository

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.rollback()

    @abstractmethod
    def commit(self):
        raise NotImplementedError

    @abstractmethod
    def rollback(self):
        raise NotImplementedError


class DjangoUnitOfWork(AbstractUnitOfWork):
    def __init__(self):
        self.users = DjangoUserRepository()

    def __enter__(self):
        return super().__enter__()

    def __exit__(self, *args):
        super().__exit__(*args)

    def commit(self):
       
        pass
           

    def rollback(self):
   
        pass


class InMemoryUnitOfWork(AbstractUnitOfWork):
    def __init__(self):
        self.users = InMemoryRepository()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass  # rien Ã  rollback

    def commit(self):
        pass  # pas de DB rÃ©elle

    def rollback(self):
        pass

#ici nous ne gerons pas les commit et roolback car django le gere bien deja maios demain vous travailler avec sqlalchemy ou autre vous devez ajouter self.commit() et self.rollback()
```
le service layer devient:

```
import hashlib
from users.core.models import User
from users.core.exceptions import UserAlreadyExists, UserNotFound
from users.core.commands import RegisterUserCommand
from users.adapters.repository import AbstractUserRepository
from users.services.unit_of_work import AbstractUnitOfWork
class UserService:
    def __init__(self, uow: AbstractUnitOfWork):
        self.uow = uow

    # ---------- Use Case 1 : Register ----------
    def register(self, cmd: RegisterUserCommand) -> User:
        with self.uow:
            if self.uow.users.exists(cmd.email):
                raise UserAlreadyExists(
                    f"Un utilisateur avec l'email {cmd.email} existe dÃ©jÃ ."
                )

            password_hash = self._hash_password(cmd.password)
            user = User(email=cmd.email)
            user.password_hash = password_hash

            saved_user = self.uow.users.save(user)
      
            return saved_user

    # ---------- Use Case 2 : Authenticate ----------
    def authenticate(self, email: str, password: str) -> User:
        with self.uow:
            user = self.uow.users.get_by_email(email)
            if not user:
                raise UserNotFound("Utilisateur introuvable")

            if user.password_hash != self._hash_password(password):
                raise ValueError("Mot de passe incorrect")

            # Pas besoin de commit ici, juste lecture
            return user

    # ---------- Utils ----------
    def _hash_password(self, password: str) -> str:
        return hashlib.sha256(password.encode()).hexdigest()
```

Parfait ! Dans ton **README.md**, tu peux introduire la **couche Infrastructure** de maniÃ¨re claire et pÃ©dagogique pour les autres dÃ©veloppeurs. Lâ€™idÃ©e est de montrer **son rÃ´le dans lâ€™architecture DDD**, comment elle se connecte au **Domain**, et donner un exemple concret (ici avec Django). Voici un exemple de texte que tu peux mettre dans ton README :

---

## ðŸ“¦ Infrastructure Layer

La **couche Infrastructure** est responsable de tout ce qui est liÃ© aux **technologies externes**, Ã  la **persistance des donnÃ©es** et aux **interfaces avec le monde extÃ©rieur**. Elle ne contient **aucune logique mÃ©tier**, mais fournit des **adaptateurs** pour que le domaine puisse interagir avec le systÃ¨me (base de donnÃ©es, API, fichiers, services externesâ€¦).

### ðŸ”‘ Objectifs principaux

1. **Connexion avec la base de donnÃ©es**

   * GÃ©rer le stockage et la rÃ©cupÃ©ration des entitÃ©s du domaine.
   * Fournir des **repositories** conformes aux interfaces du domaine (`AbstractUserRepository`).

2. **Isolation du domaine**

   * La couche **domain** ne connaÃ®t pas Django ou dâ€™autres frameworks.
   * Lâ€™infrastructure adapte le domaine Ã  la technologie choisie.

3. **Support pour les Use Cases / Services**

   * Permet aux services applicatifs (`UserService`) dâ€™utiliser les repositories sans savoir comment les donnÃ©es sont stockÃ©es.
   * Exempleâ€¯: la mÃªme interface peut Ãªtre utilisÃ©e pour **tests unitaires** avec `InMemoryRepository` ou en production avec `DjangoUserRepository`.

4. **Gestion des transactions**

   * Les unitÃ©s de travail (`UnitOfWork`) sont implÃ©mentÃ©es ici pour garantir la cohÃ©rence de la base.

---

### ðŸ›  Exemple avec Django

**ModÃ¨le Django qui sert dâ€™adaptateur pour le domaine :**

```python
from django.db import models
import uuid
from users.core.models import User

class UserModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    email = models.EmailField(unique=True)
    password = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = "users"

    # --- MAPPING vers le domaine ---
    def to_domain(self) -> User:
        user = User(
            email=self.email,
            password=self.password,
            is_active=self.is_active,
            created_at=self.created_at,
        )
        user.id = str(self.id)
        return user

    @classmethod
    def from_domain(cls, user: User) -> "UserModel":
        return cls(
            id=user.id,
            email=user.email,
            password=user.password,
            is_active=user.is_active,
        )
```

**Repository Django (Infrastructure) :**

```python
from users.core.models import User
from interface_django.account.models import UserModel
from users.adapters.repository import AbstractUserRepository
from typing import Optional, List


class DjangoUserRepository(AbstractUserRepository):
    def exists(self, email: str) -> bool:
        return UserModel.objects.filter(email=email).exists()

    def _get_by_email(self, email: str) -> Optional[User]:
        obj = UserModel.objects.filter(email=email).first()
        return obj.to_domain() if obj else None

    def _get_by_id(self, user_id: str) -> Optional[User]:
        obj = UserModel.objects.filter(id=user_id).first()
        return obj.to_domain() if obj else None

    def _list(self) -> List[User]:
        return [u.to_domain() for u in UserModel.objects.all()]

    def _save(self, user: User) -> User:
        obj = UserModel.from_domain(user)
        obj.save()
        return obj.to_domain()

    def _exists(self, email: str) -> bool:
        return self.exists(email)

```

**Utilisation dans un service :**

```python
from users.services.user_services import UserService
from users.adapters.django_repository import DjangoUserRepository

repo = DjangoUserRepository()
service = UserService(repo)

user = service.register(RegisterUserCommand(email="a@example.com", password="123"))
```

---

 **Ã€ retenir** :

* La couche **Infrastructure** ne fait que **mapper et persister** les entitÃ©s du domaine.
* Toute la logique mÃ©tier reste dans la couche **Domain** (`User`, `Email`, etc.).
* Cela permet de changer facilement de technologie ou de base de donnÃ©es sans toucher au cÅ“ur mÃ©tier.


Ce mini POC illustre comment appliquer une architecture **Domain Driven Design (DDD)** avec **Django**.  
Lâ€™objectif est de sÃ©parer clairement :
- Le **domaine mÃ©tier** (`users/`) â€” indÃ©pendant de Django
- Lâ€™**infrastructure Django** (`interface_django/`) â€” persistence, API, configurations


## clone du poc

```
git clone https://github.com/mtchalim3/poc-djang-ddd.git

cd poc-django-ddd
pip install -r requirements.txt
# lancer les migrations
cd interface_django
python manage.py makemigrations
python manage.py migrate
cd ..
#lancer les tests
make test
#formatage
make black

```

video:
[Voir la dÃ©mo du POC](docs/demo.mp4)


##  Points importants

### 1. SÃ©paration du domaine et de lâ€™infra
- Le **dossier `users/`** contient le **cÅ“ur mÃ©tier** (core models, services, rÃ¨gles).  
- Le domaine **nâ€™importe jamais Django** (il est framework-agnostic).  
- Lâ€™infra Django (`interface_django/`) ne fait quâ€™exposer le domaine via API et gÃ©rer la persistence.

---

### 2. Configuration Django
Dans `interface_django/interface_django/settings.py`, il faut dÃ©clarer vos apps avec leur **chemin complet** :

```python
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "interface_django.account.apps.AccountConfig",  #  app Django
    "rest_framework",
]
```

Ainsi :

Le domaine ne dÃ©pend pas de Django ORM

Les tests sur User restent simples et rapides

4. Use Cases exposÃ©s dans Django

Les cas dâ€™usage dÃ©finis dans users/services sont appelÃ©s depuis les views.py de lâ€™app Django (interface_django/account/views.py).

Cela permet :

Django gÃ¨re les requÃªtes HTTP (API, REST, etc.)

Le domaine reste centrÃ© sur la logique mÃ©tier

5. Tests

Tests unitaires du domaine (users/tests/test_user_core.py, test_user_services.py)

Tests des repositories Django (users/tests/test_django_repo.py)

Tests dâ€™intÃ©gration via Django Views (dans account/tests/)

Exemple (pytest) :

```
import pytest
from users.adapters.django_repository import DjangoUserRepository
from users.core.models import User
from interface_django.account.models import UserModel

pytestmark = pytest.mark.django_db 

def test_save_and_get_user():
    repo = DjangoUserRepository()
    user = User(email="django@example.com", password="123456")

    saved_user = repo.save(user)

    assert saved_user.email == "django@example.com"
    assert repo.exists("django@example.com")

def test_get_by_email_returns_user():
    repo = DjangoUserRepository()
    user = User(email="test2@example.com", password="pwd")
    repo.save(user)

    fetched = repo.get_by_email("test2@example.com")

    assert fetched is not None
    assert fetched.email == "test2@example.com"

def test_list_users():
    repo = DjangoUserRepository()
    repo.save(User(email="u1@example.com", password="p1"))
    repo.save(User(email="u2@example.com", password="p2"))

    users = repo.list()
    assert len(users) == 2


```

Configuration du projet
1. setup.py

Contient la configuration standard pour packager le module Python.

2. pyproject.toml

Contient les configurations pour les outils (pytest, linters, etc.).
Important : dÃ©finir le chemin Django pour les tests avec pytest-django :
```
[tool.pytest.ini_options]
DJANGO_SETTINGS_MODULE = "interface_django.interface_django.settings"
python_files = ["tests.py", "test_*.py"]
```
Lancer le POC

Installer les dÃ©pendances :
```
pip install -r requirements.txt  
```

RÃ©sultat attendu

Domain (users/) totalement dÃ©couplÃ© de Django

Django utilisÃ© uniquement comme infra (API + ORM)

Tests simples et rapides au niveau domaine, robustes cÃ´tÃ© infra

Architecture claire, conforme aux principes DDD

 Conclusion

Ce POC dÃ©montre comment :

Organiser un projet Django selon les principes DDD

Isoler le domaine mÃ©tier du framework

Utiliser un repository pattern pour abstraire la persistence

Exposer les cas dâ€™usage via Django Views / DRF