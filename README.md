#  POC Django + Domain Driven Design (DDD)

## Introduction et explication du fonctionnement du DDD


## Introduction au Domain Driven Design (DDD)
Le Domain Driven Design est une approche de dÃ©veloppement logiciel qui place le domaine mÃ©tier au cÅ“ur de la conception. L'objectif est de crÃ©er un logiciel qui reflÃ¨te prÃ©cisÃ©ment les concepts mÃ©tier et les processus de l'organisation.

## Les trois couches principales en DDD :
### Domain Layer - Le cÅ“ur mÃ©tier :
 Contient les entitÃ©s, value objects, rÃ¨gles mÃ©tier et services de domaine

### Application Layer - Orchestration :
 Coordonne les use cases et fait le lien entre le domaine et l'infrastructure

### Infrastructure Layer - DÃ©tails techniques :
Persistence, APIs, frameworks (Django dans notre cas)

## Structure du projet:
```
poc-django-ddd/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ users/                       # DOMAIN LAYER - CÅ“ur mÃ©tier
â”‚   â”‚   â”œâ”€â”€ core/                   # ModÃ¨les mÃ©tier purs
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py           # EntitÃ©s et Value Objects
â”‚   â”‚   â”‚   â”œâ”€â”€ exceptions.py       # Exceptions mÃ©tier
â”‚   â”‚   â”‚   â””â”€â”€ commands.py         # Commandes (CQRS)
â”‚   â”‚   â”œâ”€â”€ services/               # SERVICES - Logique mÃ©tier
â”‚   â”‚   â”‚   â””â”€â”€ user_services.py    # Services de domaine
â”‚   â”‚   â””â”€â”€ adapters/               # ADAPTERS - Interfaces techniques
â”‚   â”‚       â””â”€â”€ repository.py       # Interface de repository
â”‚   â””â”€â”€ interface_django/           # INFRASTRUCTURE LAYER - Django
â”‚       â”œâ”€â”€ account/                # App Django
â”‚       â”‚   â”œâ”€â”€ models.py           # ModÃ¨les Django (persistence)
â”‚       â”‚   â”œâ”€â”€ views.py            # ContrÃ´leurs API
â”‚       â”‚   â””â”€â”€ urls.py             # Routes API
â”‚       â””â”€â”€ interface_django/
â”‚           â””â”€â”€ settings.py         # Configuration Django
â”œâ”€â”€ tests/                          # Tests de toutes les couches
â”‚   â”œâ”€â”€ unit/                       # Tests unitaires
â”‚   â””â”€â”€ integration/                # Tests d'intÃ©gration
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

## Explication DÃ©taillÃ©e de Chaque Couche
### 1. Domain Layer - Le CÅ“ur MÃ©tier

Le Domain Layer est le cÅ“ur mÃ©tier dâ€™une application, câ€™est lÃ  oÃ¹ rÃ©side toute la logique mÃ©tier et les rÃ¨gles de lâ€™organisation.
Il doit Ãªtre indÃ©pendant de toute technologie, câ€™est-Ã -dire sans dÃ©pendances Ã  Django, Flask, SQLAlchemy, PostgreSQL, Redis, ou toute autre librairie externe.

CaractÃ©ristiques principales :

Isolation totale :

Aucune dÃ©pendance Ã  lâ€™infrastructure (DB, frameworks web, API externes).

Ã‰crit en Python pur dans notre cas.

RÃ¨gles mÃ©tier :

Les invariants (exemple : un email valide, un mot de passe doit respecter certaines rÃ¨gles).

Les rÃ¨gles de sÃ©curitÃ© (exemple : un utilisateur inactif ne peut pas se connecter).

Les comportements mÃ©tier (exemple : activer/dÃ©sactiver un compte, valider un OTP, gÃ©rer des droits dâ€™accÃ¨s).

Ã‰lÃ©ments du Domain Layer :

EntitÃ©s (Entities) : objets qui possÃ¨dent une identitÃ© unique (exemple : User, Order, Invoice).

Valeurs (Value Objects) : objets sans identitÃ© propre, mais dÃ©finis uniquement par leurs attributs (exemple : Email, Money, Address).

Services de domaine : logique mÃ©tier complexe qui ne se rattache pas directement Ã  une entitÃ© (exemple : gÃ©nÃ©ration dâ€™un token dâ€™authentification, validation de rÃ´les).

Ã‰vÃ©nements de domaine (Domain Events) : Ã©vÃ©nements significatifs du mÃ©tier (exemple : UserRegistered, PasswordChanged).

IndÃ©pendance :

Tu pourrais exÃ©cuter le Domain Layer tout seul, sans base de donnÃ©es ni serveur web.

Si demain tu passes de Django Ã  FastAPI, ou de PostgreSQL Ã  MongoDB â†’ le domaine reste inchangÃ©.

NB: dans le domaine layer on oublie tous framework base de donnÃ©e ontravail en python pur c'est ici que toute les bonne pratique de programmation intervienne c'est ici que les tests unitaire ont lieu

users/core/models.py - EntitÃ©s et Value Objects

```
import uuid
from datetime import datetime
import re

class User:
    """
    ENTITÃ‰ MÃ‰TIER - ReprÃ©sente un utilisateur dans le domaine
    Pure Python, aucune dÃ©pendance Ã  Django
    """
    
    # Expression rÃ©guliÃ¨re pour validation email
    EMAIL_REGEX = r"^[\w\.-]+@[\w\.-]+\.\w+$"

    def __init__(self, email: str, password="Password123@#", is_active: bool = True, created_at: datetime = None):
        # IdentitÃ© unique de l'entitÃ©
        self.id = str(uuid.uuid4())
        self.password = password
        self.email = self._validate_email(email)  # Validation mÃ©tier
        self.is_active = is_active
        self.created_at = created_at or datetime.utcnow()
        self.seen = set()  # Exemple de collection mÃ©tier

    # MÃ©thodes mÃ©tier - comportements de l'entitÃ©
    def _validate_email(self, email: str) -> str:
        """RÃˆGLE MÃ‰TIER: Validation du format email"""
        if not re.match(self.EMAIL_REGEX, email):
            raise ValueError("Email invalide")
        return email.lower().strip()

    def activate(self):
        """COMPORTEMENT MÃ‰TIER: Activer un utilisateur"""
        self.is_active = True

    def deactivate(self):
        """COMPORTEMENT MÃ‰TIER: DÃ©sactiver un utilisateur"""
        self.is_active = False

    # MÃ©thodes techniques
    def __repr__(self):
        return f"User(id={self.id}, email={self.email}, is_active={self.is_active}, created_at={self.created_at})"

    def __eq__(self, value):
        """IDENTITÃ‰: Deux users sont Ã©gaux s'ils ont le mÃªme ID"""
        if isinstance(value, User):
            return self.id == value.id
        return False

    def __hash__(self):
        """HASH: BasÃ© sur l'ID unique"""
        return hash(self.id)
```
users/core/exceptions.py - Exceptions MÃ©tier

```
class UserAlreadyExists(Exception):
    pass


class UserNotFound(Exception):
    pass


```

### tests unitaire dans le domaine layer
#### test de crÃ©ation d'un nouveau utilsateur
 ```
 # nous testons ici le bon cas c'est a dire lorsque les informations sont bien forunie
 
 from users.core.models import User


def test_user_model():
    user = User(email="l9v3h@example.com", is_active=True)
    print(user)
    assert user.email == "l9v3h@example.com"
    assert user.is_active

 ```

### repository patterns

DÃ©finition du Repository Pattern

En DDD, le Repository est un service technique qui fait lâ€™intermÃ©diaire entre le domaine et la persistence (ex: base de donnÃ©es, fichiers, cache, API externe).

 En clair :

Le domaine ne connaÃ®t pas la base de donnÃ©es.

Le domaine demande juste au repository : "Donne-moi cet utilisateur", "Sauvegarde cet utilisateur".

Le repository se charge dâ€™aller dans la DB (ou autre systÃ¨me) et de retourner un objet du domaine (User), pas un objet technique (UserModel Django).

 RÃ´le du Repository

Abstraction de la persistence :
Le domaine ne doit pas dÃ©pendre du choix de la DB ou de lâ€™ORM.
(Aujourdâ€™hui tu utilises Django ORM, demain tu peux passer Ã  SQLAlchemy ou MongoDB sans changer le domaine.)

Interface mÃ©tier simple :
Le repository expose des mÃ©thodes simples comme add, get_by_id, get_by_email, list, exists.

Retourner des objets du domaine uniquement :
Jamais dâ€™objets Django ORM ou SQLAlchemy dans le domaine, toujours des entitÃ©s User.

 Pourquoi deux versions ?

InMemoryRepository : utilisÃ© pour les tests unitaires du domaine â†’ rapide, pas besoin de base de donnÃ©es.

DjangoUserRepository : utilisÃ© dans lâ€™infrastructure â†’ implÃ©mentation rÃ©elle qui utilise lâ€™ORM Django.

Les deux implÃ©mentent la mÃªme interface AbstractUserRepository, donc le domaine peut travailler avec lâ€™un ou lâ€™autre sans rien changer.
NB: le repository pattern ne doit avoir en Ã©alitÃ© quye deux fonction ) loa rigueur 3 car le repo ne fait ajouter(add) ou retoruner (get) des donnÃ©es dans la base de donnÃ©es

 Exemple simplifiÃ© : deux fonctions essentielles

Tu disais quâ€™un repository doit au moins avoir deux fonctions : add et get.
Exactement !
On peut rÃ©duire Ã§a au minimum vital :


```
from abc import ABC, abstractmethod
from typing import Optional, List
from users.core.models import User
from typing import Optional, List


class AbstractUserRepository(ABC):
    """Interface du UserRepository dans le domaine"""

    def exists(self, email: str) -> bool:
        return self._exists(email)

    def get_by_email(self, email: str) -> Optional[User]:
        return self._get_by_email(email)

    def update(self, user: User) -> User:
        return self._save(user)

    def get_by_id(self, user_id: str) -> Optional[User]:
        return self._get_by_id(user_id)

    def list(self) -> List[User]:
        return self._list()

    def save(self, user: User) -> User:
        return self._save(user)

    @abstractmethod
    def _get_by_email(self, email: str) -> Optional[User]:
        pass

    @abstractmethod
    def _get_by_id(self, user_id: str) -> Optional[User]:
        pass

    @abstractmethod
    def _list(self) -> List[User]:
        pass

    @abstractmethod
    def _save(self, user: User) -> User:
        pass

```

Puis deux implÃ©mentations :

ðŸ”¹ En mÃ©moire (tests unitaires)

```

class InMemoryRepository(AbstractUserRepository):
    def __init__(self):
        self._users = []

    def _exists(self, email: str) -> bool:
        return any(user.email == email for user in self._users)

    def _get_by_email(self, email: str) -> Optional[User]:
        return next((user for user in self._users if user.email == email), None)

    def _get_by_id(self, user_id: str) -> Optional[User]:
        return next((user for user in self._users if user.id == user_id), None)

    def _list(self) -> List[User]:
        return self._users

    def _save(self, user: User) -> User:
        self._users.append(user)
        return user

```
Avec Django ORM (prod)
```
from users.core.models import User
from interface_django.account.models import UserModel
from users.adapters.repository import AbstractUserRepository
from typing import Optional, List


class DjangoUserRepository(AbstractUserRepository):
    def exists(self, email: str) -> bool:
        return UserModel.objects.filter(email=email).exists()

    def _get_by_email(self, email: str) -> Optional[User]:
        obj = UserModel.objects.filter(email=email).first()
        return obj.to_domain() if obj else None

    def _get_by_id(self, user_id: str) -> Optional[User]:
        obj = UserModel.objects.filter(id=user_id).first()
        return obj.to_domain() if obj else None

    def _list(self) -> List[User]:
        return [u.to_domain() for u in UserModel.objects.all()]

    def _save(self, user: User) -> User:
        obj = UserModel.from_domain(user)
        obj.save()
        return obj.to_domain()

    def _exists(self, email: str) -> bool:
        return self.exists(email)

```

RÃ©sultat :

Dans les tests unitaires : on passes InMemoryUserRepository() â†’ rapide, sans DB.

Dans Django (prod) : on passes DjangoUserRepository() â†’ Ã§a persiste en DB.

Le domaine nâ€™a aucune idÃ©e de ce quâ€™il y a derriÃ¨re.


## Service layer








Ce mini POC illustre comment appliquer une architecture **Domain Driven Design (DDD)** avec **Django**.  
Lâ€™objectif est de sÃ©parer clairement :
- Le **domaine mÃ©tier** (`users/`) â€” indÃ©pendant de Django
- Lâ€™**infrastructure Django** (`interface_django/`) â€” persistence, API, configurations


## clone du poc

```
git clone https://github.com/mtchalim3/poc-djang-ddd.git

cd poc-django-ddd
pip install -r requirements.txt
# lancer les migrations
cd interface_django
python manage.py makemigrations
python manage.py migrate
cd ..
#lancer les tests
make test
#formatage
make black

```

video:
[Voir la dÃ©mo du POC](docs/demo.mp4)


##  Points importants

### 1. SÃ©paration du domaine et de lâ€™infra
- Le **dossier `users/`** contient le **cÅ“ur mÃ©tier** (core models, services, rÃ¨gles).  
- Le domaine **nâ€™importe jamais Django** (il est framework-agnostic).  
- Lâ€™infra Django (`interface_django/`) ne fait quâ€™exposer le domaine via API et gÃ©rer la persistence.

---

### 2. Configuration Django
Dans `interface_django/interface_django/settings.py`, il faut dÃ©clarer vos apps avec leur **chemin complet** :

```python
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "interface_django.account.apps.AccountConfig",  #  app Django
    "rest_framework",
]
```

Ainsi :

Le domaine ne dÃ©pend pas de Django ORM

Les tests sur User restent simples et rapides

4. Use Cases exposÃ©s dans Django

Les cas dâ€™usage dÃ©finis dans users/services sont appelÃ©s depuis les views.py de lâ€™app Django (interface_django/account/views.py).

Cela permet :

Django gÃ¨re les requÃªtes HTTP (API, REST, etc.)

Le domaine reste centrÃ© sur la logique mÃ©tier

5. Tests

Tests unitaires du domaine (users/tests/test_user_core.py, test_user_services.py)

Tests des repositories Django (users/tests/test_django_repo.py)

Tests dâ€™intÃ©gration via Django Views (dans account/tests/)

Exemple (pytest) :

```
import pytest
from users.adapters.django_repository import DjangoUserRepository
from users.core.models import User
from interface_django.account.models import UserModel

pytestmark = pytest.mark.django_db 

def test_save_and_get_user():
    repo = DjangoUserRepository()
    user = User(email="django@example.com", password="123456")

    saved_user = repo.save(user)

    assert saved_user.email == "django@example.com"
    assert repo.exists("django@example.com")

def test_get_by_email_returns_user():
    repo = DjangoUserRepository()
    user = User(email="test2@example.com", password="pwd")
    repo.save(user)

    fetched = repo.get_by_email("test2@example.com")

    assert fetched is not None
    assert fetched.email == "test2@example.com"

def test_list_users():
    repo = DjangoUserRepository()
    repo.save(User(email="u1@example.com", password="p1"))
    repo.save(User(email="u2@example.com", password="p2"))

    users = repo.list()
    assert len(users) == 2


```

Configuration du projet
1. setup.py

Contient la configuration standard pour packager le module Python.

2. pyproject.toml

Contient les configurations pour les outils (pytest, linters, etc.).
Important : dÃ©finir le chemin Django pour les tests avec pytest-django :
```
[tool.pytest.ini_options]
DJANGO_SETTINGS_MODULE = "interface_django.interface_django.settings"
python_files = ["tests.py", "test_*.py"]
```
Lancer le POC

Installer les dÃ©pendances :
```
pip install -r requirements.txt  
```

RÃ©sultat attendu

Domain (users/) totalement dÃ©couplÃ© de Django

Django utilisÃ© uniquement comme infra (API + ORM)

Tests simples et rapides au niveau domaine, robustes cÃ´tÃ© infra

Architecture claire, conforme aux principes DDD

 Conclusion

Ce POC dÃ©montre comment :

Organiser un projet Django selon les principes DDD

Isoler le domaine mÃ©tier du framework

Utiliser un repository pattern pour abstraire la persistence

Exposer les cas dâ€™usage via Django Views / DRF